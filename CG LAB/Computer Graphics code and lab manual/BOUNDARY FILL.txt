#include <iostream>             // Include necessary libraries
#include <math.h>
#include <time.h>
#include <GL/glut.h>

using namespace std;           // Use the standard namespace

void delay(float ms){          // Define a function to delay execution
    clock_t goal = ms + clock();  // Calculate the goal time for delay
    while(goal>clock());        // Wait until the goal time is reached
}
//BY AKSHIT KOTNALA


void init(){                   // Initialize OpenGL settings
    glClearColor(1.0,1.0,1.0,0.0);  // Set clear color to white
    glMatrixMode(GL_PROJECTION); // Set the matrix mode to projection
    gluOrtho2D(0,640,0,480);     // Set the orthographic projection
}

void bound_it(int x, int y, float* fillColor, float* bc){  // Boundary fill algorithm
    float color[3];            // Array to store the current pixel color
    glReadPixels(x,y,1.0,1.0,GL_RGB,GL_FLOAT,color);  // Read the current pixel color

    // Check if the current pixel color is not the boundary color or fill color
    if((color[0]!=bc[0] || color[1]!=bc[1] || color[2]!=bc[2])&&(
     color[0]!=fillColor[0] || color[1]!=fillColor[1] || color[2]!=fillColor[2])){
        glColor3f(fillColor[0],fillColor[1],fillColor[2]);  // Set fill color
        glBegin(GL_POINTS);     // Begin drawing points
            glVertex2i(x,y);    // Draw a point at the current position
        glEnd();                // End drawing points
        glFlush();              // Flush the buffer to display the point

        // Recursively fill the neighboring pixels
        bound_it(x+1,y,fillColor,bc);
        bound_it(x-2,y,fillColor,bc);
        bound_it(x,y+2,fillColor,bc);
        bound_it(x,y-2,fillColor,bc);
    }
}

void mouse(int btn, int state, int x, int y){  // Mouse callback function
    y = 480-y;                 // Adjust the y-coordinate
    if(btn==GLUT_LEFT_BUTTON)  // Check if left mouse button is pressed
    {
        if(state==GLUT_DOWN)   // Check if mouse button is pressed down
        {
            float bCol[] = {1,0,0};  // Boundary color (red)
            float color[] = {0,0,1}; // Fill color (blue)
            bound_it(x,y,color,bCol);  // Call boundary fill function
        }
    }
}

void world(){                  // Display function
    glLineWidth(3);            // Set line width
    glPointSize(2);            // Set point size
    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer
    glColor3f(1,0,0);          // Set drawing color to red
    glBegin(GL_LINE_LOOP);     // Begin drawing a line loop
        glVertex2i(150,100);   // Define the vertices of the triangle
        glVertex2i(300,300);
        glVertex2i(450,100);
    glEnd();                   // End drawing the line loop
    glFlush();                 // Flush the buffer to display the triangle
}

int main(int argc, char** argv){  // Main function
    glutInit(&argc, argv);     // Initialize GLUT
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);  // Set display mode
    glutInitWindowSize(640,480);  // Set window size
    glutInitWindowPosition(200,200);  // Set window position
    glutCreateWindow("Boundary Fill");  // Create a window with title
    glutDisplayFunc(world);    // Set display function
    glutMouseFunc(mouse);      // Set mouse callback function
    init();                    // Initialize OpenGL settings
    glutMainLoop();            // Enter the GLUT main loop
    return 0;
}
